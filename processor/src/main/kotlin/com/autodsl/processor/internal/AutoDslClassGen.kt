/*
 * Copyright 2018 Juan Ignacio Saravia
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.autodsl.processor.internal

import com.autodsl.annotation.AutoDsl
import com.autodsl.annotation.AutoDslMarker
import com.autodsl.processor.*
import com.squareup.kotlinpoet.*
import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata
import me.eugeniomarletti.kotlin.metadata.kotlinMetadata
import java.io.File
import javax.annotation.processing.ProcessingEnvironment

/**
 * Generates code for AutoDsl.
 */
internal fun ProcessingEnvironment.generateClass(targetType: TargetType) {
    val classElement = targetType.element
    val packageOfClass = this.elementUtils.getPackageOf(classElement).toString()
    val builderClassName = targetType.builderName

    val generatedSourcesRoot: String = getGeneratedSourcesRoot()
    if (generatedSourcesRoot.isEmpty()) {
        throw ProcessingException(
            classElement,
            "Can't find the target directory for generated Kotlin files."
        )
    }
    val file = File(generatedSourcesRoot)
    file.mkdir()
    val fileSpec = FileSpec.builder(packageOfClass, builderClassName)

    val classBuilderClassName = getClassName(classElement, builderClassName)
    // create builder class
    val classBuilder = TypeSpec.classBuilder(builderClassName)
        .primaryConstructor(FunSpec.constructorBuilder().build())
        .addAnnotation(AutoDslMarker::class)

    if (targetType.isInternal) {
        classBuilder.addModifiers(KModifier.INTERNAL)
    }


    val typeMetadata: KotlinClassMetadata = classElement.kotlinMetadata as? KotlinClassMetadata ?: return

    // setup properties from the available constructor
    targetType.constructor.parameters.forEach { param ->
        val builder =
            generateParamCode(
                AutoDslParam(
                    param.key, param.value,
                    targetType.proto, typeMetadata.data.nameResolver
                ), classBuilderClassName
            )
        builder.imports.forEach { fileSpec.addImport(it.packageName, it.name) }
        builder.properties.forEach { classBuilder.addProperty(it) }
        builder.functions.forEach { classBuilder.addFunction(it) }
        builder.types.forEach { classBuilder.addType(it) }
    }

    val classElementTypeName = classElement.asType().asTypeName()
    // add build function to create real object
    val buildFunSpec = targetType.createBuildFun(classElementTypeName)
    classBuilder.addFunction(buildFunSpec)

    // create extension function for DSL
    val extFun = targetType.createDslExtFun(classBuilderClassName, classElementTypeName)

    fileSpec.addFunction(extFun.build())
        .addComment("Code generated by AutoDsl. Do not edit.")
        .addType(classBuilder.build())
        .build().writeTo(file)
}

private fun TargetType.createBuildFun(classElementTypeName: TypeName): FunSpec {
    return FunSpec.builder("build")
        .returns(classElementTypeName)
        // todo loop could be improved
        .addStatement("return $classElementTypeName(${constructor.parameters.keys.joinToString { it }})")
        .build()
}

private fun TargetType.createDslExtFun(
    classBuilderClassName: ClassName,
    classElementTypeName: TypeName
): FunSpec.Builder {
    val extensionFunParams = ParameterSpec.builder(
        BLOCK_FUN_NAME,
        LambdaTypeName.get(
            receiver = classBuilderClassName,
            returnType = Unit::class.asTypeName()
        )
    ).build()

    val classElementAnnotation = element.getAnnotation(AutoDsl::class.java)
    val extFunName = classElementAnnotation.getDslNameOrDefault(element.simpleName.toString().decapitalize())
    val extFun = FunSpec.builder(extFunName)
        .addParameter(extensionFunParams)
        .returns(classElementTypeName)
        .addStatement("return $builderName().apply($BLOCK_FUN_NAME).build()")

    if (isInternal) {
        extFun.addModifiers(KModifier.INTERNAL)
    }
    return extFun
}